<html>
<head>
<title>Python</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>

<body bgcolor="white" text="black" link="blue" vlink="navy" alink="red">

<h1>Dictionaries</h1>

<p>https://docs.python.org/3/library/stdtypes.html#mapping-types-dict

<h3>INTRODUCTION</h3>

<p>A mapping object maps 'hashable' values to arbitrary objects. 
Mappings are mutable objects. 
There is currently only one standard mapping type, the 'dictionary'.

<p>Dictionary order is guaranteed to be insertion order (Py3.7+).

<pre>
+----------------------------+---------------------------+
| Operation                  | Meaning                   |
+----------------------------+---------------------------+
| D = {} ; D = dict()        | empty dict                |
| D = {1: "a", 5: "e"}       | creation (two pairs)      |
| D = dict(iterable)         | creation from iterable    |
| {x:x**2 for x in iterable} | dict comprehension        |
| len(D)                     | length (number of pairs)  |
| D[key] = value             | add/update (key, value)   |
| D[key]                     | get value at key          |
| D2 = dict(D1)              | shallow copy              |
| D2 = D1.copy()             | shallow copy              |
| D2 = {**D1}                | copy (Py3)                |
| key in D                   | containing O(1)           |
| key not in D               | containing O(1)           |
| D.has_key(key)             | containing (Py2)          |
| for key in D: pass         | iteration                 |
| max(D), min(D)             | the largest|smallest key  |
| del D[key]                 | remove (key, value)       |
| D.clear()                  | remove all pairs          |
| del D                      | remove the name D         |
+----------------------------+---------------------------+
</pre>

<h3>METHODS</h3>

<hr><pre>
# Creation

D = {}
D[k1] = v1 ; D[k2] = v2 ; D[k3] = v3

D = {k1: v1, k2: v2, k3: v3}
D = {k1: v1, k2: v2, k3: v3, }   # last comma is ignored

D = dict(pair_list)
D = dict([(k1, v1), (k2, v2), (k3, v3)])

D = dict(zip(key_list, value_list))
D = dict(zip([k1, k2, k3], [v1, v2, v3]))

D.keys()         # [k1, k2, k3] Py2
D.values()       # [v1, v2, v3] Py2
D.items()        # [(k1, v1), (k2, v2), (k3, v3)] Py2

D.keys()         # return a view of keys, Py3
D.values()       # return a view of values, Py3
D.items()        # return a view of items, (key, value) pairs, Py3

list(D)   # [k1, k2, k3]
# iter(D) is a shortcut for iter(D.keys()).
# reversed(D) is a shortcut for reversed(D.keys()).

D = dict(name1=v1, name2=v2)   # {'name1':v1, 'name2':v2}

D.get(key)                    # return D[key] or None
D.get(key, value)             # return D[key] or value
D.setdefault(key, value)
# if key in D then return D[key],
# if key not in D then set D[key] = value and return value

D.pop(key)                    # return D[key] and remove
D.pop(key, value)             # return D[key] (or value) and remove
D.popitem()                   # return 2-tuple (key, value)

D = dict.fromkeys(S[, value])    # S is a sequence, value is None by default
D = dict.fromkeys(range(4), 0)   # {0: 0, 1: 0, 2: 0, 3: 0}
D = dict.fromkeys("abc", 1)   # {'a': 1, 'c': 1, 'b': 1}

D.update(E)   # E is a dict, for k in E: D[k] = E[k]
D.update(**E)   # E is a dict, the same
D.update(F)   # F=[("x",10),("y",20)], for (k,v) in F: D[k] = v
D.update(name1=value1, name2=value2)
# the same as D.update({'name1': value1, 'name2': value2})
</pre><hr>

<h3>DICT COMPREHENSION</h3>

<hr><pre>
D = {x: x**2 for x in range(9)}        # Py3 and Py2.7
D = dict((x, x**2) for x in range(9))    # generator

D = {x: x*3 for x in "qwerty"}          # Py3 and Py2.7
D = dict((x, x*3) for x in "qwerty")    # generator
</pre><hr>

</body>
</html>
