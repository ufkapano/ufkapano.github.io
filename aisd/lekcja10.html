<html>
<head>
<title>Lekcja 10</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>

<body bgcolor="white" text="black" link="blue" vlink="navy" alink="red">

<p><a href="index.html">AiSD (index)</a>
<hr>

<h1>AiSD (10) - drzewa BST</h1>

<p>OBOWIĄZKOWE DO PRZESŁANIA: jedno zadanie

<h3>WPROWADZENIE</h3>

<p>W <strong>drzewach BST</strong> (ang. <em>Binary Search Tree</em>, 
binarne drzewo poszukiwań) przeglądanie wierzchołków w kolejności 
<em>inorder</em> daje elementy posortowane niemalejąco. 
Aby to uzyskać trzeba wstawiać elementy do drzewa w następujący sposób:

<ul>
<li>Jeżeli łącze jest puste, to tworzymy węzeł z elementem.
<li>Jeżeli łącze nie jest puste, to porównujemy wstawiany element 
z elementem przechowywanym w węźle. Elementy mniejsze umieszczamy są 
w lewym podrzewie, a większe lub równe w prawym poddrzewie.
W pewnych rozwiązaniach duplikaty są ignorowane.
</ul>

<p>Koszt wykonania podstawowych operacji w drzewie BST 
(<em>insert</em>, <em>search</em>, <em>remove</em>) jest rzędu O(h), 
gdzie h jest wysokością drzewa.
Jeżeli drzewo BST jest zrównoważone, wtedy h ~ log(n).
W przypadku zdegenerowanym h = n.

<hr><pre>
// Szablon dla binarnego drzewa poszukiwań.
template &lt;typename T&gt;
class BinarySearchTree {
    BSTNode&lt;T&gt; *root;
public:
    BinarySearchTree() : root(nullptr) {} // konstruktor domyślny
    ~BinarySearchTree() { delete root; } // trzeba wyczyścić
    void clear() { delete root; root = nullptr; }
    bool empty() const { return root == nullptr; }
    T& top() { assert(root != nullptr); return root->value; } // podgląd korzenia
    void insert(const T& item) { root = insert(root, item); }
    void remove(const T& item); // usuwanie przez złączanie
    // Szukając element dostajemy wskaźnik do elementu lub nullptr.
    T* search(const T& item) const {
        auto ptr = search(root, item);
        return ((ptr == nullptr) ? nullptr : &amp;(ptr->value));
    }
    T* iter_search(const T& item) const { // wg libavl
        for (auto node=root; node != nullptr; ) {
            if (item == node->value) {
                return &amp;(node->value);
            } else if (item &lt; node->value) {
                node = node->left;
            } else {
                node = node->right;
            }
        }
        return nullptr;
    }
    T* find_min() const;
    T* find_max() const;
    void preorder() { preorder(root); }
    void inorder() { inorder(root); }
    void postorder() { postorder(root); }
    void iter_preorder();
    void iter_inorder(); // trudne
    void iter_postorder(); // trudne
    void bfs(); // przejście poziomami (wszerz)
    void display() { display(root, 0); }

    // Metody bezpośrednio odwołujące się do node.
    // Mogą działać na poddrzewie.
    BSTNode&lt;T&gt; * insert(BSTNode&lt;T&gt; *node, const T& item); // zwraca nowy korzeń
    BSTNode&lt;T&gt; * search(BSTNode&lt;T&gt; *node, const T& item) const; // zwraca węzeł
    BSTNode&lt;T&gt; * remove(BSTNode&lt;T&gt; *node); // zwraca nowy korzeń poddrzewa
    void preorder(BSTNode&lt;T&gt; *node);
    void inorder(BSTNode&lt;T&gt; *node);
    void postorder(BSTNode&lt;T&gt; *node);
    void display(BSTNode&lt;T&gt; *node, int level);
    virtual void visit(BSTNode&lt;T&gt; *node) {
        assert(node != nullptr);
        std::cout &lt;&lt; "visiting " &lt;&lt; node->value &lt;&lt; std::endl;
    }
};
</pre><hr><pre>
template &lt;typename T&gt;
BSTNode&lt;T&gt; * BinarySearchTree&lt;T&gt;::insert(BSTNode&lt;T&gt; *node, const T& item) {
    if (node == nullptr) {
        return new BSTNode&lt;T&gt;(item);
    }
    if (item &lt; node->value) {
        node->left = insert(node->left, item);
    } else {
        node->right = insert(node->right, item);
    }
    return node; // zwraca nowy korzeń
}
</pre><hr><pre>
template &lt;typename T&gt;
BSTNode&lt;T&gt; * BinarySearchTree&lt;T&gt;::search(BSTNode&lt;T&gt; *node, const T& item) const {
    if (node == nullptr || node->value == item) {
        return node;
    } else if (item &lt; node->value) {
        return search(node->left, item);
    } else {
        return search(node->right, item);
    }
}
</pre><hr>

<h3>ROTACJE DRZEWA BST</h3>

<p><strong>Rotacja drzewa</strong> (ang. <em>tree rotation</em>) 
jest operacją na drzewie BST,
która zmienia jego lokalną strukturę bez zmiany kolejności elementów,
przy przechodzeniu przez drzewo BST metodą inorder.
Wyróżnia się dwie symetryczne operacje: rotacja w prawo i rotacja w lewo.

<hr><pre>
|     X     --[w prawo]-o    Y     | Kolejność inorder: |
|    / \                    / \    | A Y B X C          |
|   Y   C   o-[w lewo]--   A   X   |                    |
|  / \                        / \  |                    |
| A   B                      B   C |                    |
</pre><hr><pre>
template &lt;typename T&gt;
BSTNode&lt;T&gt; * BinarySearchTree&lt;T&gt;::rotate_right(BSTNode&lt;T&gt; *node) {
    if (node->left == nullptr)
        return node; // bez zmian
    BSTNode&lt;T&gt; *top = node; // węzeł X
    node = top->left; // węzeł Y
    top->left = node->right; // przepinamy węzeł B
    node->right = top; // przepinamy węzeł X
    return node; // zwracamy węzeł Y
}
</pre><hr><pre>
template &lt;typename T&gt;
BSTNode&lt;T&gt; * BinarySearchTree&lt;T&gt;::rotate_left(BSTNode&lt;T&gt; *node) {
    if (node->right == nullptr)
        return node; // bez zmian
    BSTNode&lt;T&gt; *top = node; // węzeł Y
    node = top->right; // węzeł X
    top->right = node->left; // przepinamy węzeł B
    node->left = top; // przepinamy węzeł Y
    return node; // zwracamy węzeł X
}
</pre><hr>

<h3>USUWANIE PRZEZ ZŁĄCZANIE</h3>

<hr><pre>
template &lt;typename T&gt;
void BinarySearchTree&lt;T&gt;::remove(const T& item) { // usuwanie przez złączanie
    // Najpierw znajdujemy węzeł i jego rodzica.
    BSTNode&lt;T&gt; *node = root;
    BSTNode&lt;T&gt; *prev = nullptr;
    while (node != nullptr) {
        if (node->value == item)
            break;
        prev = node;
        if (item &lt; node->value) {
            node = node->left;
        } else {
            node = node->right;
        }
    }
    // Szukamy przyczyny przerwania pętli while.
    if (node != nullptr && node->value == item) {
        // node ma być usunięty.
        if (node == root) {
            root = remove(node);
        } else if (prev->left == node) {
            prev->left = remove(node);
        } else {
            prev->right = remove(node);
        }
    } else if (root != nullptr) {
        ; // klucza nie znaleziono
    } else { // root == nullptr
        ; // drzewo jest puste
    }
}
</pre><hr><pre>
template &lt;typename T&gt;
BSTNode&lt;T&gt; * BinarySearchTree&lt;T&gt;::remove(BSTNode&lt;T&gt; *node) {
    // Mamy usunąć węzeł i zwrócić nowy korzeń poddrzewa.
    assert(node != nullptr);
    BSTNode&lt;T&gt; *new_root;
    if (node->right == nullptr) { // node nie ma prawego dziecka
        new_root = node->left;
    } else if (node->left == nullptr) { // node nie ma lewego dziecka
        new_root = node->right;
    } else { // obecne lewe i prawe dziecko
        new_root = node; // zapisujemy stary korzeń
        node = node->left; // idziemy w lewo
        while (node->right != nullptr) { // idziemy w prawo do końca
            node = node->right;
        }
        node->right = new_root->right; // prawe poddrzewo przełączone
        node = new_root; // węzeł do usunięcia
        new_root = node->left; // nowy korzeń
    }
    delete node;
    return new_root;
}
</pre><hr><pre>
|      X                 Usuwamy węzeł X, który ma dwoje dzieci.
|    /   \               Nowym korzeniem poddrzewa będzie Y.
|   Y     C       Y         Z jest poprzednikiem X.
|  / \           / \
| A   Z         A   Z
|    /             / \
|   B             B   C
</pre><hr><pre>
|      X                Y jest nowym korzeniem i poprzednikiem X.
|    /   \          
|   Y     C       Y
|  /             / \
| A             A   C
</pre><hr>

<h3>ALGORYTM DSW</h3>

<p>https://en.wikipedia.org/wiki/Day%E2%80%93Stout%E2%80%93Warren_algorithm

<p><strong>Algorytm DSW</strong> (Day, Stout, Warren) służy do zrównoważenia 
drzewa BST. Algorytm działa w miejscu i w czasie O(n).

<h3>ZADANIE 10.1 (MIN i MAX)</h3>

<p>Napisać funkcje <em>find_min()</em> i <em>find_max()</em> znajdujące 
odpowiednio wartość najmniejszą i największą w drzewie BST.
Funkcje powinny zwracać wskaźnik do wartości lub <em>nullptr</em> 
dla pustego drzewa.

<h3>ZADANIE 10.2 (SUCCESSOR)</h3>

<p>Napisać funkcję <em>find_successor()</em> znajdujący następnik danego
węzła przy przechodzeniu <em>inorder</em> 
(lub <em>nullptr</em>, jeżeli go nie ma).
Węzły powinny posiadać łącze do rodzica.

<h3>ZADANIE 10.3 (PREDECESSOR)</h3>

<p>Napisać funkcję <em>find_predecessor()</em> znajdujący poprzednik danego
węzła przy przechodzeniu <em>inorder</em> 
(lub <em>nullptr</em>, jeżeli go nie ma).
Węzły powinny posiadać łącze do rodzica.

<h3>ZADANIE 10.4 (TEST BST)</h3>

<p>Napisać funkcję sprawdzającą, czy drzewo binarne jest drzewem BST.
Nie wystarczy sprawdzić dla każdego węzła, czy zachodzi 
<em>node-&gt;left-&gt;value &lt;= node-&gt;value</em>, oraz 
<em>node-&gt;value &lt;= node-&gt;right-&gt;value</em>. 
Musimy do węzła przekazać informację od rodzica o ograniczeniach 
na wartość przechowywaną w węźle.

<hr><pre>
|       5          Przykład drzewa binarnego, które nie jest drzewem BST.
|     /   \        Wartość 6 jest większa od 3, ale nie jest mniejsza od 5.
|   3       8
|  / \     / \
| 1   6   7   9
</pre><hr>

<h3>ZADANIE 10.5 (DSW)</h3>

<p>Zaimplementować algorytm DSW.

<hr>
<p><a href="index.html">AiSD (index)</a>

</body>
</html>
