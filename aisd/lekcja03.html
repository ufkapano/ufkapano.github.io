<html>
<head>
<title>Lekcja 3</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>

<body bgcolor="white" text="black" link="blue" vlink="navy" alink="red">

<p><a href="index.html">AiSD (index)</a>
<hr>

<h1>AiSD (3) - ADT LIST (implementacja tablicowa)</h1>

<p>OBOWIĄZKOWE DO PRZESŁANIA: jedno zadanie.

<h3>WPROWADZENIE</h3>

<p>ADT LIST reprezentuje skończoną liczbę uporządkowanych elementów,
które mogą się powtarzać. 
Elementy są <em>uporządkowane</em> (niekoniecznie posortowane!), 
czyli każdy element ma określoną pozycję (indeks) na liście.
Jeżeli liczba uporządkowanych elementów może być 
potencjalnie nieskończona, to używa się pojęcia <em>strumienia</em>. 
Lista to podstawowy przykład kontenera do przechowywania elementów,
przy czym w ogólności elementy nie muszą być tego samego typu. 
Typowe operacje dla ADT LIST są następujące:

<ul>
<li>konstruktor tworzący pustą listę,
<li>testowanie, czy lista nie jest pusta [empty()],
<li>odczyt liczby elementów na liście, 
to jest <strong>długość</strong> listy [size()],
<li>odczyt największej możliwej liczby elementów
(<em>capacity</em>) [max_size()],
<li>dołączanie elementu na początek listy [push_front(item)],
<li>dołączanie elementu na koniec listy [push_back(item)],
<li>dostęp do głowy (<em>head</em>), 
czyli pierwszego (lewego skrajnego) elementu [front()],
<li>dostęp do ogona (<em>tail</em>), 
czyli ostatniego (prawego skrajnego) elementu [back()],
<li>usunięcie elementu pierwszego [pop_front()],
<li>usunięcie elementu ostatniego [pop_back()],
<li>czyszczenie listy, czyli usunięcie wszystkich elementów [clear()],
<li>dostęp do elementu o danym indeksie i,
<li>dołączanie elementu przed element na pozycji i [insert()],
<li>usunięcie elementu o danym indeksie i [erase()],
<li>sortowanie listy [sort()],
<li>łączenie dwóch <strong>posortowanych</strong> list w jedną [merge()].
</ul>

<p>ADT LIST jest typowo implementowany jako lista powiązana 
(liniowa lub cykliczna) lub tablica, zwykle o zmiennej długości.

<p>W STL indeksowany dostęp do elementów zapewniają kontenery
<em>std::vector</em> (ciągły obszar pamięci) i 
<em>std::deque</em> (sekwencja indywidualnie alokowanych tablic 
o stałym rozmiarze).

<hr><pre>
// Kontenery w STL realizujące w pewnym stopniu ADT LIST.

// https://en.cppreference.com/w/cpp/container/vector

// https://en.cppreference.com/w/cpp/container/forward_list

// https://en.cppreference.com/w/cpp/container/list

// https://en.cppreference.com/w/cpp/container/deque
</pre><hr><pre>
// Przy kopiowaniu szeregu elementów tablicy przydają się funkcje z STL.

// https://en.cppreference.com/w/cpp/algorithm/copy
// Funkcja odpowiednia przy kopiowaniu w lewo przy nakładaniu się zakresów.
// Podajemy tylko początek zakresu docelowego (d_first).

It2 copy( It1 first, It1 last, It2 d_first );

// Przykład. Kopiowanie w obrębie jednej tablicy a.
// +--+--+--+--+--+--+--+--+--+--+
// |a0|a1|a2|a3|a4|a5|a6|a7|a8|a9| stan początkowy
// +--+--+--+--+--+--+--+--+--+--+
// std::copy(a+5, a+9, a+3); // kopiowanie 4 elementów: a5, a6, a7, a8
// +--+--+--+--+--+--+--+--+--+--+
// |a0|a1|a2|a5|a6|a7|a8|a7|a8|a9| stan końcowy
// +--+--+--+--+--+--+--+--+--+--+
</pre><hr><pre>
// https://en.cppreference.com/w/cpp/algorithm/copy_backward
// Funkcja odpowiednia przy kopiowaniu w prawo przy nakładaniu się zakresów.
// Podajemy tylko koniec zakresu docelowego (d_last).

It2 copy_backward( It1 first, It1 last, It2 d_last );

// Przykład. Kopiowanie w obrębie jednej tablicy a.
// +--+--+--+--+--+--+--+--+--+--+
// |a0|a1|a2|a3|a4|a5|a6|a7|a8|a9| stan początkowy
// +--+--+--+--+--+--+--+--+--+--+
// std::copy_backward(a+2, a+6, a+7); // kopiowanie 4 elementów: a5, a4, a3, a2
// +--+--+--+--+--+--+--+--+--+--+
// |a0|a1|a2|a3|a2|a3|a4|a5|a8|a9| stan końcowy
// +--+--+--+--+--+--+--+--+--+--+
</pre><hr>

<h3>ZADANIE 3.1 (TABLICA STATYCZNA)</h3>

<p>Przygotować implementację realizującą ADT LIST na bazie
tablicy o stałym rozmiarze (tablica statyczna), 
ustalanym w czasie tworzenia listy.
Będzie to klasa <em>ArrayList</em> umieszczona w pliku 
<a href="arraylist.h">arraylist.h</a>.
Uzupełnić plik <em>arraylist.h</em>, stworzyć funkcję main() i testy
sprawdzające działanie interfejsu list.

<h3>ZADANIE 3.2 (TABLICA DYNAMICZNA)</h3>

<p>https://chalmersgu-data-structure-courses.github.io/OpenDSA/Published/ChalmersGU-DSABook/html/ListArrayDynamic.html

<p>Przygotować implementację realizującą ADT LIST na bazie
tablicy o zmieniającym się rozmiarze (tablica dynamiczna).
Będzie to klasa <em>ArrayList</em> umieszczona w pliku <em>arraylist.h</em>.
Początkowy rozmiar tablicy (min_size) może wynosić 1, 2 lub 4.
Po zapełnieniu tablicy rozmiar może się powiększać o stały czynnik,
np. może się podwajać. Powiększanie tablicy o stałą liczbę miejsc
nie jest dobrym rozwiązaniem, ze względu na wielokrotne kopiowanie elementów.
Po usunięciu pewnej liczby elementów tablica może się zmniejszać,
aż do osiągnięcia początkowego rozmiaru minimalnego.

<p>Zbadajmy liczbę kopiowań elementów podczas powiększania tablicy 
o czynnik 2. Zakładamy, że elementy są kolejno wstawiane do tablicy.
<br>resize(2), kopiowany 1 element
<br>resize(4), kopiowane 2 elementy
<br>resize(8), kopiowane 4 elementy
<br>resize(16), kopiowane 8 elementów
<br>resize(32), kopiowane 16 elementów
<br>resize(64), kopiowane 32 elementy
<br>resize(128), kopiowane 64 elementy
<br>resize(2^k), kopiowane 2^{k-1} elementów

<p>Załóżmy najbardziej niekorzystny przypadek, że liczba elementów
wstawionych do tablicy wynosi n = 2^k + 1.
Tablica rozszerzy się do rozmiaru 2^{k+1}.
Łączna liczba kopiowań elementów wynosi
<br>1 + 2 + 4 + ... + 2^k = (1 - 2^{k+1}) / (1 - 2) = 2^{k+1} -1
= 2 * 2^k -1 = 2 (n-1) -1 = 2n -3.
<br>Pokazaliśmy, że stosując strategię podwajania rozmiaru tablicy,
wstawianie do tablicy n elementów wymaga mniej niż 2n kopiowań elementów.
Inaczej mówiąc, wstawienie jednego elementu do tablicy kosztuje 
co najwyżej dwa kopiowania elementów.

<p>Osobnym zagadnieniem jest zmniejszanie rozmiaru tablicy
przy zmniejszającej się liczbie elementów.
Załóżmy, że aktualny rozmiar tablicy wynosi 2^k.
Dobrą strategią jest zmniejszanie rozmiaru do 2^k / 2,
jeżeli liczba elementów zmaleje do 2^k / 4 lub 2^k / 3, a nie do 2^k / 2.
Unikamy wtedy częstego powiększania i zmniejszania rozmiaru tablicy,
kiedy liczba elementów oscyluje koło 2^k / 2.

<hr>
<p><a href="index.html">AiSD (index)</a>

</body>
</html>
