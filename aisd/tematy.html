<html>
<head>
<title>AiSD</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>

<body bgcolor="white" text="black" link="blue" vlink="navy" alink="red">

<h1>Propozycje tematów projektów zaliczeniowych</h1>

<h3>UWAGI OGÓLNE</h3>

<p>W celu zaliczenia ćwiczeń z AiSD należy:
<br>(1) zaliczyć 10 zestawów zadań,
<br>(2) zaliczyć dwa kolokwia,
<br>(3) zaliczyć projekt programistyczny w C++
[kod plus dokumentacja (README.md, HTML, PDF); 
minimum 100 wierszy kodu;
nie używać <em>using namespace std;</em>; 
<em>Makefile</em> do kompilacji z flagami <em>-Wall -std=c++11</em>].

<p>Możliwe sposoby przesyłania rozwiązań zestawów zadań:
<br>(1) email z linkiem do repozytorium w serwisie GitHub,
gdzie składowane są kody źródłowe programów,
<br>(2) email z linkiem do archiwum ZIP w chmurze UJ,
<br>(3) email z archiwum ZIP w załączniku.

<h3>TEMATY PROJEKTÓW</h3>

<ul>

<li>Implementacja wielomianów na bazie list powiązanych pojedynczo 
(szablon, współczynniki typu T).
Działania na wielomianach: dodawanie (operator+), odejmowanie (operator-), 
mnożenie (operator*), obliczanie wartości wielomianu (algorytm Hornera),
porównywanie (operator==, operator!=), wyświetlanie (operator&lt;&lt;),
konstruktor kopiujący, podstawienie kopiujące (operator=).
Wielomiany są równe, gdy ich różnica jest wielomianem zerowym.
Klasa <em>Term</em> opisuje węzeł listy powiązanej i
przechowuje jeden niezerowy wyraz wielomianu (c*x^n).
Klasa <em>Poly</em> przechowuje łącze do posortowanej malejąco listy powiązanej wyrazów
i implementuje działania.
Przydają się funkcje clear(), is_zero(), operator[]
(odczyt współczynnika przy danej potędze x,
brak wyrazu oznacza zerowy współczynnik),
degree() (stopień wielomianu, zerowy wielomian ma stopień zero).

<li>Implementacja wielomianów na bazie tablic (szablon, współczynniki typu T).
Działania na wielomianach: dodawanie (operator+), odejmowanie (operator-), 
mnożenie (operator*), obliczanie wartości wielomianu (algorytm Hornera),
porównywanie (operator==, operator!=), wyświetlanie (operator&lt;&lt;),
konstruktor kopiujący, podstawienie kopiujące (operator=).
Wielomiany są równe, gdy ich różnica jest wielomianem zerowym.
Klasa <em>Poly</em> przechowuje tablicę współczynników i implementuje działania.
Przydają się funkcje clear(), is_zero(), operator[]
(odczyt współczynnika przy danej potędze x,
brak wyrazu oznacza zerowy współczynnik),
degree() (stopień wielomianu, zerowy wielomian ma stopień zero).

<li>Implementacja kwaternionów podobnie do <em>std::complex</em>
[https://en.wikipedia.org/wiki/Quaternion].
Działania na kwaternionach: dodawanie (operator+), odejmowanie (operator-), 
mnożenie (operator*), sprzężenie (conjugate lub conj), moduł (abs),
kwadrat modułu (norm),
porównywanie (operator==, operator!=), wyświetlanie (operator&lt;&lt;),
konstruktor kopiujący, podstawienie kopiujące (operator=).

<li>Obliczanie wielomianu szachowego.
<br>[https://en.wikipedia.org/wiki/Rook_polynomial]

<li>Implementacja list z przeskokami (ang. <em>skip list</em>).
Ma to być szablon z elementami na liście typu T.
<br>[https://en.wikipedia.org/wiki/Skip_list]

<li>Drzewo czerwono-czarne (ang. <em>red-black tree</em>),
czyli drzewo BST o dodatkowych właściwościach.
<br>[https://en.wikipedia.org/wiki/Red%E2%80%93black_tree]

<li>Drzewo AVL, czyli drzewo BST, w którym dla każdego wezła różnica wysokości
leweo i prawego poddrzewa może się różnić co najwyżej o jeden.
<br>[https://en.wikipedia.org/wiki/AVL_tree]

<li>Drzewo rozchylane (ang. <em>splay tree</em>), czyli drzewo BST
zmieniające swoją strukturę tak, że często wyszukiwane węzły stają się
szybsze do znalezienia.
<br>[https://en.wikipedia.org/wiki/Splay_tree]

<li>Drzewo ukorzenione o dowolnym stopniu rozgałęzień.
Cormen str. 245, reprezentacja 
<em>na lewo syn, na prawo brat</em>.

<li>Drzewo przedziałowe (ang. <em>interval tree</em>), 
czyli drzewo binarne do przechowywania danych o przedziałach na osi liczbowej
[Cormen str. 351]. Dzięki tej strukturze można wydajnie znajdować
wszystkie przedziały przekrywające się z danym punktem lub przedzałem.
<br>[https://en.wikipedia.org/wiki/Interval_tree]

<li>Drzewo przedziałowe (ang. <em>segment tree</em>), czyli
struktura danych do przechowywania informacji o tablicy liczbowej A[0...n-1].
Struktura pozwala na szybkie zapytania O(log n) dotyczące dowolnej
podtablicy A[left...right], takie jak suma elementów,
wartość najmniejsza/największa.
Można też w czasie O(log n) dodawać pewną liczbę do każdego elementu podtablicy.
<br>[https://cp-algorithms.com/data_structures/segment_tree.html]

<li>Kopiec trójkowy (ang. <em>ternary heap</em>), 
czyli kopiec wykorzystujący drzewo trójkowe
(węzeł ma najwyżej troje dzieci) zamiast drzewa binarnego
[https://en.wikipedia.org/wiki/D-ary_heap].

<hr><pre>
# Obliczanie pozycji rodzica i dzieci w kopcu trójkowym dla węzła o numerze n.
int heap_parent(int n) { return (n-1) / 3; }
int heap_left(int n) { return (3 * n + 1); }
int heap_middle(int n) { return (3 * n + 2); }
int heap_right(int n) { return (3 * n + 3); }
</pre><hr>

<li>Program do obsługi biblioteki (użytkownicy, książki, wypożyczanie).
Nie należy używać serwerów dużych baz danych, można użyć biblioteki SQLite.

<li>Program symulujący konta w banku.
Operacje: zakładanie i usuwanie konta, wpłata, wypłata, przelew,
zapis i odczyt bazy z pliku.
Nie należy używać serwerów dużych baz danych, można użyć biblioteki SQLite.

<li>Program do rezerwacji biletów lotniczych.
Nie należy używać serwerów dużych baz danych, można użyć biblioteki SQLite.

<li>Baza danych książek, płyt, filmów, itp. 
(jeden typ elementów, wystarczy jedna tabela).
Operacje: dodawanie, usuwanie, wyszukiwanie rekordów,
wypisywanie zawartości bazy, zapis i odczyt bazy z pliku.
Przy wyszukiwaniu powinno wystarczyć podanie fragmentu danych z rekordu,
np. fragmentu nazwiska autora czy tytułu.
Wygodne jest wczytywanie bazy przy starcie programu, potem zapisywanie bazy
do pliku po każdej zmianie danych (dodanie/usuwanie rekordu).
Nie należy używać serwerów dużych baz danych, można użyć biblioteki SQLite.

<li>Obliczanie mediany kroczącej (ang. <em>running median</em>).
<br>[https://en.wikipedia.org/wiki/Moving_average#Moving_median]

<li>Implementacja systemu T9 (<em>predictive text</em>), 
stosowanego w telefonach komórkowych 
do łatwiejszego pisania tekstów za pomocą klawiatury 3x4.
Używa się 8 przycisków znaczących 2-9.
Jeżeli wyświetli się kilka wyrazów, ale pierwszy nie jest tym właściwym,
to klawisz '*' daje przejście do następnego wyrazu.
<br>[https://en.wikipedia.org/wiki/T9_(predictive_text)]


<pre>
+------+------+------+
|1     |2 abc |3 def |
+------+------+------+
|4 ghi |5 jkl |6 mno |
+------+------+------+
|7 pqrs|8 tuv |9 wxyz|
+------+------+------+
| *    | 0    | #    |
+------+------+------+
</pre>

</ul>

</body>
</html>
