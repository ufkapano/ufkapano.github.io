<html>
<head>
<title>Python</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>

<body bgcolor="white" text="black" link="blue" vlink="navy" alink="red">

<h1>Zadania</h1>


<p>OBOWIĄZKOWE DO PRZESŁANIA: jedno zadanie ze stosem lub kolejką (12.2 - 12.7), 
zadanie z kolejką przypadkową (12.8)

<p>W rozwiązaniach należy umieścić kod testujący przygotowane funkcje.

<h3>ZADANIE 12.1 (MATRIX)</h3>

<p>W pliku <em>matrix.py</em> zdefiniować klasę <em>Matrix</em>
reprezentującą macierz prostokątną.
Wykorzystać wyjątek <em>ValueError</em> do obsługi błędów, np.
przy dodawaniu macierzy liczby wierszy i kolumn obu macierzy
powinny być zgodne; indeksy wierszy i kolumn muszą być w określonych
przedziałach (Python wykryje tylko przekroczenie zakresu listy).
Poprawić metodę do wyświetlania macierzy.

<hr><pre>
class Matrix:

    def __init__(self, rows=1, cols=1):
        self.rows = rows
        self.cols = cols
        self.data = [0] * rows * cols

    def __str__(self):
        return str(self.data)

    def __getitem__(self, pair):   # odczyt m[i,j]
        i, j = pair
        return self.data[i * self.cols + j]

    def __setitem__(self, pair, value):   # m[i,j] = value
        i, j = pair
        self.data[i * self.cols + j] = value

    def __add__(self, other): pass   # dodawanie macierzy

    def __sub__(self, other): pass   # odejmowanie macierzy

    def __mul__(self, other): pass   # mnożenie macierzy

# Zastosowanie.
m = Matrix(3, 4)
m[1, 2] = 12     # metoda __setitem__
print(m[1, 2])   # metoda __getitem__
print(m)         # metoda __str__
</pre><hr>

<h3>ZADANIE 12.2 (STACK)</h3>

<p>Poprawić implementację tablicową stosu tak, aby korzystała
z wyjątków w przypadku pojawienia się błędu.
Metoda <em>pop()</em> ma zgłaszać błąd w przypadku pustego stosu.
Metoda <em>push()</em> ma zgłaszać błąd w przypadku przepełnienia stosu.
Napisać kod testujący stos.

<pre>
</pre>


<h3>ZADANIE 12.3 (STACK)</h3>

<p>Stworzyć implementację tablicową stosu do przechowywania 
bez powtórzeń liczb całkowitych od 0 do size-1. 
Powtarzająca się liczba ma być ignorowana bez żadnej akcji
(inne podejście to wyzwolenie wyjątku).
Wskazówka: stworzyć drugą tablicę, w której 0 lub 1 na pozycji i 
oznacza odpowiednio brak lub istnienie liczby i na stosie. 

<pre>
</pre>

<h3>ZADANIE 12.4 (QUEUE)</h3>

<p>Poprawić metodę <em>get()</em>, 
aby w przypadku pustej kolejki zwracała wyjątek.
Poprawić metodę <em>put()</em> w tablicowej implementacji kolejki, 
aby w przypadku przepełnienia kolejki zwracała wyjątek.
Napisać kod testujący kolejkę.

<h3>ZADANIE 12.5 (PRIORITYQUEUE)</h3>

<p>Poprawić metodę <em>remove()</em> w pythonowej implementacji kolejki
priorytetowej tak, aby uniknąć kosztownego pobierania elementu
ze środka listy.

<p>Poprawić metodę <em>remove()</em> w tablicowej implementacji kolejki
priorytetowej, aby w przypadku pustej kolejki generowała wyjątek.

<p>Poprawić metodę <em>insert()</em> w tablicowej implementacji kolejki
priorytetowej, aby w przypadku przepełnienia kolejki generowała wyjątek.

<pre>
</pre>

<h3>ZADANIE 12.6 (PRIORITYQUEUE)</h3>

<p>Załóżmy, że w kolejce priorytetowej będą przechowywane elementy,
których priorytet można zmienić za pomocą metody <em>increase(value)</em>.
Dodać kolejce metodę <em>increase(value)</em>, która pozwoli na zmianę
priorytetów wszystkich elementów w kolejce o wartość <em>value</em>.
Taka kolejka może symulować działanie systemu operacyjnego,
który zwiększa priorytet zadaniom czekającym w kolejce do wykonania.
Cykliczne zwiększanie priorytetów zapobiega długiemu przebywaniu
w kolejce zadań o niskim początkowym priorytecie.

<h3>ZADANIE 12.7 (PRIORITYQUEUE)</h3>

<p>W pythonowej implementacji kolejki priorytetowej
dodać możliwość ustawiania sposobu porównywania elementów
znajdujących się w kolejce.

<hr><pre>
class PriorityQueue:

    def __init__(self, cmpfunc=cmp):
        self.items = []
        self.cmpfunc = cmpfunc
</pre><hr>

<h3>ZADANIE 12.8 (RANDOMQUEUE)</h3>

<p>Stworzyć ADT w postaci kolejki losowej, z której elementy
będą pobierane w losowej kolejności.
Zadbać o to, aby każda operacja była wykonywana w stałym czasie,
niezależnie od liczby elementów w kolejce.

<hr><pre>
class RandomQueue:

    def __init__(self): pass
    #def __init__(self, size=10): pass   # wersja z ograniczeniem na rozmiar

    def insert(self, item): pass   # wstawia element w czasie O(1)

    def remove(self): pass   # zwraca losowy element w czasie O(1)

    def is_empty(self): pass

    def is_full(self): pass

    def clear(self): pass   # czyszczenie listy
</pre><hr>

</body>
</html>
