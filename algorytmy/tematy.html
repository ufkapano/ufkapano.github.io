<html>
<head>
<title>Python</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>

<body bgcolor="white" text="black" link="blue" vlink="navy" alink="red">

<h1>Propozycje tematów projektów zaliczeniowych</h1>

<h3>WIELOMIANY</h3>

<ul>

<li>Wielomiany gęste na bazie list Pythona.

<li>Wielomiany rzadkie na bazie słowników.
Każdy wyraz wielomianu jest przechowywany w słowniku jako para
(stopień, współczynnik).

<li>Wielomiany na bazie list powiązanych pojedynczo i posortowanych.
Jeden węzeł listy reprezentuje jeden wyraz wielomianu
i przechowuje atrybuty 'degree' oraz 'coefficient'.
Węzły są sortowane względem atrybutu 'degree'.

<li>Wielomiany w reprezentacji wykorzystującej wartości
wielomianu w wybranych punktach.
Cormen str. 923.

</ul>

<h3>MACIERZE</h3>

<ul>

<li>Macierze gęste na bazie list.

<hr><pre>
class Matrix(object):
    def __init__(self, rows=1, cols=1):
        self.rows = rows
        self.cols = cols
        self.data = [0] * rows * cols
    def __str__(self):
        return str(self.data)
    def __getitem__(self, pair):    # odczyt m[i, j]
        i, j = pair
        return self.data[i * self.cols + j]
    def __setitem__(self, pair, value): # m[i, j] = value
        i, j = pair
        self.data[i * self.cols + j] = value
</pre><hr>

<li>Macierze rzadkie na bazie słowników.

<hr><pre>
class Matrix(dict): pass
</pre><hr>

</ul>

<h3>CIAŁA LICZBOWE</h3>

<ul>

<li>Kwaterniony.
Implementacja działań na kwaternionach.

<hr><pre>
class Quat:
    def __init__(self, a=0, b=0, c=0, d=0):
        self.q = [float(a), float(b), float(c), float(d)]
</pre><hr>

<li>Ciało liczbowe skończone o charakterystyce będącej liczbą pierwszą.
Jest to zbiór Z/mod m, gdzie m jest liczbą pierwszą.
Zapis liczb: F(0), F(1), ..., F(m-1).
Implementacja działań, ewentualnie wielomianów w tym ciele.

<hr><pre>
class F:
    m = 5       # liczba pierwsza, parametr
# Przykład.
# F(2) + F(4) zwraca F(1).
# F(2) * F(4) zwraca F(3).
</pre><hr>

</ul>

<h3>DRZEWA I KOPCE</h3>

<ul>

<li>Drzewa BST z łączem do rodzica i algorytm DSW.

<hr><pre>
class Node:
    def __init__(self, data=None, left=None, right=None, parent=None):
        self.data = data
        self.left = left
        self.right = right
        self.parent = parent
    def __str__(self):
        return str(self.data)
</pre><hr>

<li>Drzewa czerwono-czarne (red-black trees).

<li>Drzewa splay.

<li>Drzewa AVL.

<li>Drzewa ukorzenione o dowolnym stopniu rozgałęzień.
Cormen str. 245, reprezentacja 
<em>na lewo syn, na prawo brat</em>.

<hr><pre>
class Node:
    def __init__(self, data=None, left=None, right=None, parent=None):
        self.data = data
        self.left_child = left
        self.right_sibling = right
        self.parent = parent
    def __str__(self):
        return str(self.data)
</pre><hr>

<li>Drzewo przedziałowe, czyli drzewo binarne do przechowywania
danych o przedziałach liczbowych. Cormen str. 351.

<li>Kopce Fibonacciego [trudne]. Cormen str. 513.

<li>Kopiec trójkowy.

<hr><pre>
def heap_parent(n): return (n-1) / 3
def heap_left(n): return (3 * n + 1)
def heap_middle(n): return (3 * n + 2)
def heap_right(n): return (3 * n + 3)
</pre><hr>


</ul>

<h3>GRAFY</h3>

<ul>

<li>Dla ADT grafów z wykładu stworzyć implementację grafów
opartą na macierzy sąsiedztwa (lista list).
Wierzchołki są liczbami int od 0 do n-1.
Zaimplementować BFS i DFS.

<li>Dla ADT grafów z wykładu stworzyć implementację grafów
opartą na liście sąsiedztwa (lista list).
Wierzchołki są liczbami int od 0 do n-1.
Zaimplementować BFS i DFS.

<li>Dla ADT grafów z wykładu stworzyć implementację grafów
opartą na liście krawędzi.
Zaimplementować BFS i DFS.

<li>Dla ADT grafów z wykładu stworzyć implementację grafów
opartą na macierzy incydencji.
Zaimplementować BFS i DFS.

<li>Algorytm kolorowania wierzchołków grafu.

<li>Algorytm kolorowania krawędzi grafu.

<li>Algorytm znajdowania największego zbioru niezależnego w grafie.

<li>Algorytm znajdowania najmniejszego zbioru dominującego w grafie.

<li>Znajdowanie cyklu Eulera (każda krawędź przebyta dokładnie raz).

<li>Znajdowanie cyklu Hamiltona (każdy wierzchołek odwiedzony dokładnie raz).

</ul>

<h3>GRAFY WAŻONE</h3>

<ul>

<li>Algorytm Boruvki - minimalne drzewo rozpinające 
dla grafu nieskierowanego ważonego spójnego.

<li>Algorytm Kruskala - minimalne drzewo rozpinające 
dla grafu nieskierowanego ważonego spójnego.

<li>Algorytm Prima - minimalne drzewo rozpinające 
dla grafu nieskierowanego ważonego spójnego.

<li>Algorytm Bellmana-Forda - znajdowanie ścieżki o najmniejszej wadze 
pomiędzy dwoma wierzchołkami w grafie ważonym.

<li>Algorytm Dijkstry - znajdowania najkrótszej ścieżki z pojedyńczego 
źródła w grafie nieskierowanym o nieujemnych wagach krawędzi.

<li>Algorytm Floyda-Warshalla - znajdowanie najkrótszych ścieżek 
pomiędzy wszystkimi parami wierzchołków w grafie ważonym.

<li>Algorytm A* - algorytm heurystyczny znajdowania najkrótszej ścieżki 
w grafie ważonym.

<li>Problem komiwojażera (ang. Traveling Salesman Problem, TSP), np.
algorytm najbliższych sąsiadów (z powtórzeniami lub bez), 
algorytm sortowania krawędzi,
algorytm genetyczny, symulowane wyżarzanie.

</ul>

<h3>SIECI PRZEPŁYWOWE</h3>

<ul>

<li>Algorytm Forda-Fulkersona znajdujący maksymalny przepływ.

<li>Algorytm Edmondsa-Karpa znajdujący maksymalny przepływ.

</ul>

<h3>GEOMETRIA OBLICZENIOWA</h3>

<ul>

<li>Wyznaczanie otoczki wypukłej, np. Graham, Jarvis, quickhull
[https://en.wikipedia.org/wiki/Convex_hull].

<li>Implementacja drzewa czwórkowego. Przykładowe zastosowania: 
wyznaczanie punktów należących do mniejszego obszaru,
znajdowanie punktu najbliższego do danego, 
detekcja kolizji obiektów
[https://en.wikipedia.org/wiki/Quadtree].

<li>Triangulacja Delaunaya (trudne)
[https://en.wikipedia.org/wiki/Delaunay_triangulation].

<li>Wyznaczanie pary najdalszych punktów (trudne)
[https://en.wikipedia.org/wiki/Rotating_calipers].

<li>Wielokąty monotoniczne - test monotoniczności O(n), triangulacja O(n), 
należenie punktu do wielokąta O(log n)
[https://en.wikipedia.org/wiki/Monotone_polygon].

</ul>

<h3>INNE</h3>

<ul>

<li>Baza danych książek, płyt, filmów, aktorów, itp. 
Wystarczy jeden typ obiektów w jednej tabeli.
Baza powinna być zapisywana do pliku (txt, CSV, JSON).
Operacje na bazie: wstawianie, usuwanie, wyszukiwanie, listowanie.
Nie należy używać serwerów dużych baz danych, 
można użyć biblioteki SQLite (moduł 'sqlite3')
[https://docs.python.org/3/library/sqlite3.html].

<li>Generowanie labiryntu i jego zapis do pliku, 
np. Wilson, Aldous-Broder, Kruskal, Prim.

<li>Wyszukiwanie wzorca w tekście algorytmem KMP.
Funkcja 'pattern_matching(text, pattern)' powinna zwracać indeks i 
id którego nastąpiło dopasowanie wzorca.

<li>Wybrany algorytm przetwarzania tekstu.

<li>Algorytm Kadane dla tablicy 1D i 2D.
Funkcje kadane1d(arr) i kadane2d(arr) powinny zwracać sumę elementów 
podmacierzy i odpowiednie zakresy indeksów podmacierzy
[https://en.wikipedia.org/wiki/Maximum_subarray_problem].

<li>Problem plecakowy (ang. knapsack problem).

<li>Algorytm Needlemana-Wunscha (bioinformatyka).

<li>Badanie perkolacji [https://en.wikipedia.org/wiki/Percolation_theory].

<li>Gra w statki na konsoli lub z GUI.
Należy m.in. dostarczyć funkcję generującą przypadkowe rozmieszczenie
statków na planszy.

<li>Algorytm min-max w zastosowaniu do gry w kółko i krzyżyk
[https://en.wikipedia.org/wiki/Minimax,
https://en.wikipedia.org/wiki/Tic-tac-toe].

<li>Algorytm min-max w zastosowaniu do gry w Connect Four
[https://en.wikipedia.org/wiki/Minimax,
https://en.wikipedia.org/wiki/Connect_Four].

<li>Wybrany algorytm kompresji danych.

<li>Wybrany algorytm szyfrowania.

<li>Implementacja systemu T9 (predictive text), stosowanego w telefonach
komórkowych do łatwiejszego pisania tekstów za pomocą klawiatury 3x4.

<li>Generowanie fraktali w 2D 
[https://en.wikipedia.org/wiki/Diffusion-limited_aggregation].

<li>Generowanie obrazu zbioru Mandelbrota
[https://en.wikipedia.org/wiki/Mandelbrot_set].

<li>Gra w życie (Life)
[https://pl.wikipedia.org/wiki/Gra_w_%C5%BCycie].

<li>Obliczanie wielomianu szachowego
[https://en.wikipedia.org/wiki/Rook_polynomial].

<li>Implementacja list z przeskokami 
[https://en.wikipedia.org/wiki/Skip_list].

<li>Obliczanie mediany kroczącej (ang. running median) 
dla strumienia danych (iterable)
[https://en.wikipedia.org/wiki/Moving_average#Moving_median].

<!--
Podejście z dwoma kopcami, chyba bierze się pod uwagę wszystkie dane.
Chyba coś jest źle, bo jak przyjdą dane uporządkowane,
to trzeba by przerzucać dane między kopcami, a tego nie ma.

https://www.geeksforgeeks.org/median-of-stream-of-integers-running-integers/
-->

</ul>

</body>
</html>
