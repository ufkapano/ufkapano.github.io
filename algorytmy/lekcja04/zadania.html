<html>
<head>
<title>Zadania</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
</head>

<body bgcolor="white" text="black" link="blue" vlink="navy" alink="red">

<h1>Zadania</h1>


<p>OBOWIĄZKOWE DO PRZESŁANIA: wszystko oprócz 4.1

<p>Prosty sposób na automatyczne sprawdzenie kodu:
<br>assert result == expected_result

<p>W zadaniach budujemy całe napisy, a nie wyświetlamy po kawałku.

<p>W przypadku wykrycia błędów (np. nieprawidłowe argumenty) w Pythonie
rzucamy wyjątkiem, np. raise ValueError("komunikat"),
a nie wypisujemy komunikatów przez print.

<h3>ZADANIE 4.1</h3>

<p>Jaki będzie wynik poniższego kodu i dlaczego?

<hr><pre>
X = "qwerty"

def func():
    print(X)

func()
</pre><hr><pre>
X = "qwerty"

def func():
    X = "abc"

func()
print(X)
</pre><hr><pre>
X = "qwerty"

def func():
    global X
    X = "abc"

func()
print(X)
</pre><hr>

<h3>ZADANIE 4.2</h3>

<p>Rozwiązania zadań 3.5 i 3.6 z poprzedniego zestawu
zapisać w postaci funkcji, które zwracają pełny string
przez <em>return</em>.
Funkcje nie powinny pytać użytkownika o dane, tylko korzystać z argumentów.

<hr><pre>
def make_ruler(n): pass

def make_grid(rows, cols): pass
</pre><hr>

<h3>ZADANIE 4.3</h3>

<p>Napisać iteracyjną wersję funkcji <em>factorial(n)</em> obliczającej silnię.

<pre>
</pre>

<h3>ZADANIE 4.4</h3>

<p>Napisać iteracyjną wersję funkcji <em>fibonacci(n)</em>
obliczającej n-ty wyraz ciągu Fibonacciego.

<pre>
</pre>

<h3>ZADANIE 4.5</h3>

<p>Napisać funkcję <em>odwracanie(L, left, right)</em> 
odwracającą kolejność elementów na liście od numeru left do right włącznie. 
Lista jest modyfikowana w miejscu (in place).
Rozważyć wersję iteracyjną i rekurencyjną.

<pre>
</pre>

<h3>ZADANIE 4.6</h3>

<p>Napisać funkcję  <em>sum_seq(sequence)</em>
obliczającą sumę liczb zawartych w sekwencji, 
która może zawierać zagnieżdżone podsekwencje. 
Wskazówka: rozważyć wersję rekurencyjną, a sprawdzanie, czy element
jest sekwencją, wykonać przez <em>isinstance(item, (list, tuple))</em>.

<pre>
</pre>

<h3>ZADANIE 4.7</h3>

<p>Mamy daną sekwencję, w której niektóre z elementów mogą
okazać się podsekwencjami, a takie zagnieżdżenia mogą się
nakładać do nieograniczonej głębokości.
Napisać funkcję <em>flatten(sequence)</em>, która zwróci
spłaszczoną listę wszystkich elementów sekwencji.
Wskazówka: rozważyć wersję rekurencyjną, a sprawdzanie czy element
jest sekwencją, wykonać przez <em>isinstance(item, (list, tuple))</em>.

<pre>
seq = [1,(2,3),[],[4,(5,6,7)],8,[9]]
print(flatten(seq))   # [1,2,3,4,5,6,7,8,9]
</pre>

</body>
</html>
